原文：   (Englisth) http://www.viva64.com/en/b/0324/
       （Russia) http://eax.me/cpp-will-never-die/
翻译者：  Scott Huang   
日期：   August 23,2015 于 厦门

#Criticizing the Rust Language, and Why C/C++ Will Never Die 批判Rust语言，以及C/C++为什么永远不会死

12.05.2015Eax Melanhovich

We liked the article "Criticizing the Rust Language, and Why C/C++ Will Never Die" very much. We offer the author that we will do the translation on our own, and publish it in our blog. He agreed, and we represent this article in Russian and English with great pleasure. The origin of the article is here.
简单讲，原文 http://eax.me/cpp-will-never-die/
是俄语，有人感兴趣，得到作者同意后，把它翻成英文。（译者：然后我再把它翻成中文。）


I couldn't but notice how much interest the readers of this blog had shown in the topic "should we let kittens play with new balls of wool?" So I felt like sharing a few more of my reflections on a related subject in regard to the C and C++ languages and the odds that Rust will kill them. No need to tell you that it will inevitably cause a big holy war, so before you proceed, think twice if you really want to go on reading this post and especially participate in a "constructive debate" via comments.
显而易见，这篇博文将会导致一场语言大圣战，所以，请思考两遍，确定你将会通过“有建设性的辩论”的评论参与讨论后再开始阅读这篇文章。


The original article can be found here (in Russian). It was translated and published in our blog by the author's permission.
再次说明原文是俄语：）

Note: Further in this text, I am presuming that Rust is a conscious attempt to create a fast and safe language. After all, it was initially conceived by the guys from Mozilla as a tool to develop a browser engine. But if it proves to be yet another just safe language, then I just don't get the whole thing. There is plenty of very different safe languages to choose from to any taste, and if Rust is not meant to replace C++, then (1) why does it need to include an unsafe subset?; and (2) why did the authors throw away lightweight processes from Rust? They are convenient, after all, aren't they? In other words, if I'm wrong in my assumption, then the whole affair just doesn't seem to make any sense at all.
注意： 进一步讲，我冒昧的认为Rust有意尝试创建一个快速并且安全的语言。毕竟，Mozilla的人
最初构思用它作为工具来开发一个浏览器引擎。如果它被证明是另外一个仅仅安全的语言，那么我认为
它没有达成目标。 那里有许多非常不同的安全语言供人们选择和品味，如果Rust没有打算代替C++，那么
（1）为什么它需要包含一个不安全子集； （2）并且，为什么作者要抛弃Rust的轻量级进程？毕竟它们很方便，对吧？换句话说，如果我假设错了，那么整件事情就没有讨论的意义了。


If you happen to occasionally drop by the linux.org.ru forum, be warned that this post doesn't have to do with the list of 10 purely technical reasons for not liking Rust that was discussed in this thread. A Skype conversation with dear comrade @sum3rman has revealed that there is more than one opinion on how much "technical" those reasons are. So I have to admit that the list I composed is a lousy one but I'm still taking a risk to cite some of the most interesting clauses from it here. Actually, the number of plain common sense reasons alone is big enough to not care about the technical ones.
如有你碰巧偶尔逛逛linux.org.ru论坛，那么请被提醒到这篇文章没有触及为什么不喜欢Rust的那10条纯技术理由。一条和亲爱的伙伴 @sum3rman的Skype交谈透露出不止一种的“技术性”理由的看法。所以，我不得不承认，我下面罗列的东西不讨人喜欢，但是我还是冒险从中引用一些最感兴趣的条款到这里。实际上，一些普通共识的理由自己就足够大到不用触及技术性的讨论。

It is crystal clear for every sane programmer that C/C++ is not going to die in the nearest future. No one is going to rewrite almost all of the existing desktop applications, operating system kernels, compilers, game and browser engines, virtual machines, databases, archivers, audio and video codecs, tons of other C-libraries, and so on and so forth, into other languages. This is a huge mass of fast, debugged, and time-proven code. Rewriting it is way, way too expensive, risky, and, honestly, doesn't seem to make sense except in the heads of the most frantic Rust fans. The demand for C/C++ programmers has always been high and will remain so for a long time to come.
对于每一个理智程序员都非常清楚的知道的C/C++在近期不会死掉。没有人会尝试重用新语言新编写几乎所有已经存在的桌面应用程序，操作系统内核，编译器，游戏以及浏览器引擎，虚拟机，数据库，压缩工具，音视频编码解码器，一堆其他的C库等等。 这是一批数量巨大的快速的、调试过的被时间证明了的代码。重写的代价太昂贵了和太冒险了，并且，诚实的讲，除了一些疯狂的Rust粉丝，没人会认为这有意义。 对C/C++程序员的需求从来都是高的，并且在未来很长一段时间都是。

OK, what about using Rust to write new code then?
那么用Rust写一些新的代码怎么样？

Well, as you probably remember, it is far not the first attempt to create a "better" C/C++. Take the D language, for instance. It was released in 2001 and is a good language indeed. But there are no vacancies, no decent development tools, no remarkable success stories associated with it. The OpenMW project was initially started in D but then the authors suddenly decided to completely rewrite it into C++. As they confessed, they'd been receiving piles of emails where people would say, "you are making a cool project and we'd like to contribute to it, but we don't know and neither feel like studying this silly D". Wikipedia tells us that there were a lot of other attempts besides D to kill C++ - for example Vala, Cyclone, Limbo, BitC. How many of you have even heard of these languages?
嗯，你也许记得，这并不是第一次尝试创建一个“更好的”C/C++。 拿D语言来举例。它在2001年发布，且确实是一个好的语言。但没有空间发展，没有合适的开发工具，没有著名的成功案例可以联想到它。OpenMW项目最初用D开发，但作者突然决定用C++从头重写。据他们坦白，他们收到一大堆的邮件说，“你们创建了一个很酷的项目，我想贡献一些力量给它，但是我们不懂，也不喜欢学习这个愚蠢的D语言”。维基百科告诉我们，除了D，还有有其它尝试准备杀死C++ - 举例说 Vala, Cyclone, Limbo, Bitc。 有多少人曾经听说过这些语言？

I think it's high time we started learning lessons of history. No one sane will ever start using a new language in their projects until you show them a few cool development tools supporting it, tell them a couple of success stories, and show a dozen of programmers working with that language and living close by. As for programmers, they will never - except probably for the youngest ones - spend their time and health on learning another "very best" language until you show them a few cool development tools (not a frob like Racer) and a couple of tens of thousands of ready-made libraries (not "experimental" or "unstable" or stuff like that), tell them a couple of success stories, and show them a dozen of open vacancies in their city or town. You know, it's like the "Chicken or the Egg" dilemma. On very rare occasions, this problem does get resolved (relatively representative examples are Go and Scala) - mostly thanks to investments of time and money from some large company (Google, Typesafe) who for some reason finds it worthy to popularize a new language.
我觉得人们必须理解从历史中得到教训。没有一个理智的人会在他们的项目中开始使用一个新语言，直到你展示一些非常酷的开发支持工具，告诉他们一些成功故事，并且证明一堆程序员靠这个语言做日常工作维持生活。作为程序员，他们从来不会 - 除了一些最年轻的人 - 花他们的时间和健康来学习另外一种“非常棒”的语言，直到你展示一些非常酷的开发工具（不是未完工的像Racer工具那样）和许多确实准备好的库（不是“实验性的”或者“不稳定的”东西），告诉他们一些成功案例，告诉他们有许多空缺在他们的城市或乡镇。你知道，这就像“鸡和蛋”的两难处境。只有非常少的机会，这个问题确实得到解决（最近相关的案例是Go和Scala） - 这得感谢一些大公司（Google，Typesafe)的时间和金钱投入，他们基于某种理由认为值得推广一个新语言。


As I already mentioned, there are too many non-technical reasons alone to feel skeptical about Rust. But let's imagine for a moment they just do not exist. Then there would be no reasons to not write in Rust, right? Well, this too is very arguable, to say the least.
正如我提到的，有许多非技术性的理由单独就可以质疑Rust。但是，让我们假想一会儿这些理由都不存在。那么没有理由不用Rust写程序，对吧？好的，这一点仍然非常可疑，这么说吧。

C/C++ is criticized for a variety of reasons. By the way, most of the critics have never seen C++ code in production. To put it brief and clear, the issue with C++ is that it is very fast (and also demanding little memory, battery charge, etc.) but not safe in the sense that it allows array overruns, addressing freed memory, and so on. Back in the past, this problem urged programmers to develop a variety of safe languages such as Java, C#, Python, and others. But they have proved to be too resource-demanding compared to C++ and have some other drawbacks as well - take, for instance, the inevitable "stop the world" issue during garbage collection. That's why programmers are struggling to create a language as fast as C++ but also safe. Rust is one of the candidates.
C/C++被从很多方面批判。顺便说一下，大多数批评者还从来没有看过产品级的C++代码。简短的说，C++的问题是非常快（并且只需求一点点内存，电量，等等），但是从允许数组越界，自由的存取内存等方面看不够安全。过去，这个问题促使程序员们开发出一系列安全的语言，比如Java,C#,Python还有其他等等。但是，他们被证明和C++相比，对资源需求太多，同时还有其他一些不足 - 比如， 比如当进行垃圾回收时“世界停止了”的问题。这也是为什么程序员争扎地去创建一个和C++一样快，但安全的语言。Rust是其中一个候选人。


Rust is safe indeed but, unfortunately, far from fast. By the moment of writing this article, it is comparable to Java, Go, and Haskell regarding performance:
Rust确实是安全的，但是，不幸的是，离快还差很远。在写这篇文章的时候，它和Java,go和Haskell的性能如下图所示：http://www.viva64.com/media/images/content/b/0324_Criticizing-Rust-Language-Why-Cpp-Will-Never-Die/image1.png

Picture 1
I sincerely hope that programmers will find a way to speed it up in time, but until then, it's going to be of hardly more interest than Scala or Go from the viewpoint of the safety/speed compromise. The question is still open if it is possible at all to make a language both fast and safe or if it is automatically doomed to be twice slower than C/C++ because of the constant checks for array overruns, safe wraps of bindings to C-libraries, and other stuff like that.

我真诚的希望程序员找到一个方法来及时的加速，但直到那时，几乎没有语言比Scala或者Go对安全/速度进行妥协更加感兴趣。是否可以使一种语言同时具有速度和安全，或者是否由于对数组越界，安全包裹C语言库，或则其他一些类似东西而天生注定比C/C++慢两倍的问题仍然悬而未决。
And what actually makes Rust safe, by the way? To put it simple, this is a language with a built-in code analyzer and it's a pretty tough one: it can catch all the bugs typical of C++ and dealing not only with memory management, but multithreading as well. Pass a reference to an assignable object through a pipe to another thread and then try to use this reference yourself - the program just will refuse to compile. And that's really cool.
顺便问一下，什么实际上使得Rust安全？简单的说，这门语言有内建的代码分析器，非常艰难的一条：它可以捕获全部典型的C++错误，不仅处理内存管理，而且同时考虑多线程。通过一条管道来传递一个指定对象的引用到另外一个线程，并且接着由你自己尝试使用这个引用 - 程序会拒绝通过编译。这确实非常酷。
But C++ too hasn't stood still during the last 30 years, and plenty of both static and dynamic analyzers supporting it have been released during this time. Just as one example, watch a short video about Google sanitizers - they are really very tough. Anyway, in any serious project, you use a continuous integration system and run tons of tests when compiling builds. If you don't, then your troubles are much worse than the language's lack of safety because static typing doesn't guarantee correct execution logic! So, since you run tests anyway, why not use sanitizers as well? True, they don't find all the bugs. 
但C++在过去30年一直屹立不倒，有大量的静态的和动态的分析器在这些时间段被发布出来。举一个例子，看一个关于Google sanitizers(明智分析器）的一个短片 - 他们确实非常难。不管怎么说，在任何一个严肃的项目中，你使用一个不断集成的系统，运行一大堆的测试来编译程序。如果你不这么做的话，那么你的麻烦比语言缺乏安全性而言会更糟糕，因为静态的类型不会保证程序按你的逻辑正确的运行！所以，由于你总是运行测试，为什么不同时使用sanitizer?
On the other hand, if you don't have a check for an array overrun somewhere at the deeper levels of your code and a sanitizer doesn't report the bug, maybe it's just because all the necessary checks are already provided one level higher and another one would only slow down the program? Even without sanitizers, you'll find lots of stuff just building the project with various compilers on different platforms with assert's checking your code's invariants in the "assert(obj->isValid)" fashion and with proper fuzzing. Put rough, the question actually comes down to the good old holy war about the (t)he(o)retic and kolkhoz approaches to software development (that is, an innovative yet too idealistic approach and a traditional empirical approach thought to be careless and simplistic by the supporters of the former - note by translator ).
另一方面，如果你在你的代码的某个深处地方没有检查数组越界，并且Sanitizer也没有报告这个错误，也许，这仅仅由于所有必须的检查已经在上一层提供过了，同时，多一次检查不是会使程序变慢？即使没有sanitizers，你还可以发现许多东西供你在不同平台编译项目时提供伴随适当的失真的"assert(obj -> isvalid)"风格论断来检查你代码的不变性。 粗糙的说，这个问题实际上源自过去那些好的圣战，关于异教徒和加尔各答接近软件开发（指的是，一项创新太理想化的尝试和一个传统经验主义者认为被前者的支持者无心简单化了 - 原译者注）。

You can often hear an argument that 90% of the execution time is spent executing only 10% of the code (which is, as far as I get, just an empirical law - a quick scan through the Web has failed to reveal any strict scientific researches on this subject). Therefore, you can write most of your code in safe Rust and the rest 10% (the "hot" code) in its unsafe subset, so the bad performance of the current Rust implementation is actually not a problem. OK, but doesn't it imply that I do not need Rust at all because I could write 90% of my code in Go and the rest 10% in C? Only silver bullet seekers and airy-fairy (t)he(o)retics will use Rust just for the sake of feeling contented about having 100% of a program written in seemingly one language. But these are actually two dialects of one language, which doesn't look much different from the "Java + C" or "Go + C" combos.
你经常可以听到一个争论说，90%的执行时间被10%的代码所执行（据我理解，仅仅是一条经验主义 - 对一个主题快速的扫描互联网无法替代任何严格的科学的研究）。因此，你可以用安全的Rust语言写你大部分的代码，然后，剩下的10%（那些“热”代码）写在不安全的子集中，所以现有的Rust实现实际上不会有不好的性能。好的，但这不更是暗示我根本不需要Rust，因为我可以用Go写90%代码，然后用C写剩下的10%？只有那些寻找银弹的人和幻想神话的异教徒会因为所有代码都100%用同一种语言编写而感到开心，而用Rust。但实际上一种语言有两者方言，这和"Java + C"或者"Go+C"组合没什么不同。


But the 90/10 law is rubbish anyway. Following its logic, we could rewrite 90% of WebKit or VirtualBox or GCC into Java and get the same result. But it is obviously wrong. Even if it's not because the ratio is very much different in some programs, let's do some calculations and see. Suppose an entire program is written in unsafe C/C++ and its execution time is, say, 0.9*1 (a small portion of hot code) + 0.1*1 (a bulk of cold code) = 1. Now compare it to a program written in a safe language with C inserts: 0.9*1 + 0.1*2 = 1.1, which, theoretically speaking, makes the difference of 10%. Is it much or little? Well, it depends on the project scale. For Google, even a few percent may help save millions of dollars (see Section 5, "Utilization", in the paper). Or imagine that with a next update, JVM will suddenly start requiring 10% more resources! I'm scared to even make any guesses about how many zeroes they'll get in the figure after converting those percent into dollars! 10% is a whole lot for tasks where C and C++ are used.
但实际上90/10规则是垃圾话。按照它的逻辑，我们可以用Java90%重写Webkit或者VirtualBox或者GCC而得到同样的结果。但这显然是错的。并不是这个比率因不同程序而变动太大，让我们做一些计算来瞧瞧。假设整个程序用不安全的C/C++编写，并且它的执行时间，假设是0.9*1（一小部分热代码）+0.1*1(大量的冷代码)=1。现在和一个用一个带有C代码插入的安全语言编写的程序做比较： 0.9*1 + 0.1*2 = 1.1，这样，理论上说，区别是10%。是多了还是少了？这取决于项目的规模。以Google为例，即使是很少的一点比例都可以节省大量的金钱（请看第五小结，“利用”，在这篇文章中）。或者想象当下一次更新，JVM突然开始要求多10%的资源！我都害怕猜想需要多少个0在数字后面才能把比率转化为金钱。10%是C和C++完成任务所需要的所有份额。

We keep chanting the phrase "premature optimization is the root of all evil" like a mantra. But if we want to follow it word for word, why not use bubble sort instead of quicksort in all of the code? After all, we can't know for sure where we'll get a bottleneck, can we? Why wrap regular action counters into actors or transactional memory when we can use more efficient atomics right away? And, generally speaking, in trivial cases, it doesn't make sense at all to forcedly initialize each and every single variable, implement a pile of auxiliary checks, and so on. Let there even be a 2-5% performance boost instead of 10%, but it's not that bad if it took you just an extra couple of minutes to think over. Besides, as we have already figured out, it can make a huge difference in C/C++ programs! After all, who will dare to argue that finding a hot spot, rewriting the code (perhaps tons of it) and proving it has become really faster is an easier job than think about performance in advance?
我们不停的念咒语“不成熟的优化是所有邪恶的根源”。但如果我们想逐字的跟随，为什么在所有代码里不用冒泡排序来替换快速排序？毕竟，我们没有办法确切的知道哪里是瓶颈，对吗？为什么要把普通的活动包含在actors或者事务内存中而不用马上用更加有效率的原子？并且，通常说，在小案例中，强制性的初始化每一个单独的变量，执行一堆辅助性的检查等等根本没有意义。让你仅花额外的几分钟去考虑而获取即使只有2~5%而不是10%的性能改进，其实也不坏。此外，就像我们已经指出的，这会使C/C++程序有巨大的不同！毕竟，谁敢争辩说找到了热点，重写那些代码（也许有一堆）并且证明这真的变快了是一项比预先考虑性能而言更轻松的工作？

Even apart from that speed/safety compromise issue, I'm also skeptical about the language's design as such. In particular as regards to the five types of pointers used in it. On the one hand, it's not bad to make programmers ponder if their variables are stored in the stack or heap and if they can or cannot be handled by several threads at a time. But on the other hand, imagine you are writing a program and discover at one moment that some variable should be stored in the heap instead of the stack. So you rewrite the code to use Box. Then you figure out that you actually need Rc or Arc. Again, you rewrite all that code. And then, once again, you rewrite it all to have an ordinary variable in the stack. All of that you have to do without a decent IDE at hand. Regular expressions won't help. Or you might just end up with a nightmare like "Vec<Rc<RefCell<Box<Trait>>>>" - say hello to Java! But the saddest thing about it is that the compiler already knows everything about the lifetime of every variable and could automatically insert all those Box's, Arc's, etc. But for some reason, this duty was shifted on to the programmer. It would be much more convenient to let the programmer simply write val (we are living in the third millennium, after all!) and explicitly specify Box or Rc where necessary. From this viewpoint, Rust's developers have screwed up the whole thing.
即使除了速度/安全问题比较之外，我还怀疑那语言的设计。特别对于它使用5种指针类型。一方面，让程序员仔细考虑他们的变量存放在栈或堆里，允不允许被多线程操作的想法并不差。另一方面，想象你在写一个程序，且在某一刻发现一些变量应该存在堆里而不是栈上。所以你用Box重写代码。接着你发现你实际上需要Rc或者Arc。另外，你重写了所有的代码。接着，再次，你再次重写它在栈上拥有普通变量。所有的东西你都手工操作而没有使用一个合适的IDE。正则表达式没有帮助。或者你刚刚结束一个噩梦像“Vec<Rc<RefCell<Box<Trait>>>>” - 对Java说hello吧！ 但悲伤的事情是编译器已经知道每一个变量的每一件关于使用期的事，并会自动插入所有这些Box's，Arc's等等。但由于某种原因，这个责任被转移给了程序员。让程序员简单的写val（我们活在第三个千年，毕竟！）会更加方便。并且显式的在需要的地方指定特殊的Box或者Rc。从这一点看，Rust的开发人员搞砸了整件事情。
This, in particular, makes Rust's scope much narrower. No one sane will write web and server-side software in a language like that - especially considering that it doesn't offer any significant advantages over those languages for JVM. Even Go - with normal lightweight processes (not futures) - seems a way better choice for solving these tasks. As for futures, you have to learn how to handle them right not to shoot yourself in the foot - and you are talking of "safe languages", huh? Sure, all these languages have their own peculiarities - take that very "stop the world", for example. But this problem can be solved both by splitting the code into micro services and through other techniques. And yes, no one will be willing to translate Rust into JavaScript, use it to write scripts for AWS or as a query language for MongoDB. For Android, it's also hardly probable, but for a different reason: there is way more than one architecture there, so JVM will do much better. So if you happen to think that Rust is "good for any task", I have to disappoint you.
这个，特别的，让Rust's的使用范围更加窄了。没有一个理智的人会用这样的一个语言写web或者服务器端软件 - 特别当考虑到它并没有提供比JVM相关语言更显著的优势。即使是Go  - 带有普通轻量级的进程（不是未来) - 看起来都是一种更好的选择来解决这些任务。至于未来，你得学会如何正确的操作它们而不会砸到自己的脚 - 并且你谈到“安全”的语言，啊？确实，所有的这些语言都有他们自己的独特的怪癖 - 举“整个世界都停止了”的例子。但这个问题可以通过把代码分解成小的服务或者通过其它技术而解决。并且是的，没有人愿意把Rust转为Javascript，通过它来为AWS写脚本或则为MongoDB来做查询语言。至于安卓，它也不容易可信，但是有一个不同的理由：不仅仅只有一个架构风格，所以JVM可以做的更好。所以，如果你恰巧认为Rust是“适合所有任务”的话，我让你失望了。

And here's a few more reasons to finish it off:
还有更多的理由来终结它：

Macros used as a crutch to make up for the excessive verbosity caused by the absence of normal exceptions. I already wrote about the metaprogramming issues - it is because of them, in particular, that we are hardly ever to get a decent IDE for Rust. Also, though I'm not sure, it seems that macros in Rust don't even have namespaces.
宏使用一个拐杖来弥补由于缺乏普通异常处理而导致的过度冗长。我已经写了关于元编程的问题 - 就是因为他们， 特别的， 导致我们没有办法得到一个合适的Rust IDE。 并且，即使我并不确定， 看起来Rust宏甚至并没有命名空间。
People are idiots and cargo actively encourages downloading packages directly from git repositories, bypassing Crates.io. As a result, we risk ending up with a huge mess with packages like in the Erlang world with its Rabar. By the way, I suspect the Go world has a similar trouble.
Cargo积极的鼓励绕过Crates.io从git中直接下载各种仓库就当人们是白痴。 作为一种结果，我们有被被巨量的混乱的包终结的风险，就像Erlang世界中的Rabar。顺便，我怀疑Go世界有同样的麻烦。
Like many of new languages, Rust is walking the path of simplification. I can generally understand why it doesn't have a decent inheritance and exceptions, but the fact itself that someone is making decisions for me regarding things like that makes me feel somewhat displeased. C++ doesn't restrict programmers regarding what they can or cannot use.
就像许多新语言，Rust在走简单化的路。我通常理解为什么它没有合适的继承和例外，但事实本身是有些人替我做决定让我觉得有些不舒服。C++不会限制程序员说哪些他们可以或者不可以做。
Now, since we have taken the path of simplification, why not throw away all those language extensions? The current state of things resembles the Haskell world where every programmer is coding in their own dialect.
现在，由于我们在走简单化的路，为什么不抛弃所有那些语言扩展？目前组成Haskell世界的那些东西是每个程序员用他们自己方言码出来的。
Smart pointers, for you to know, are far not free of charge and do not ensure a fixed time of garbage collection. What if some thread gets honor to free a very deep data structure? While it is wandering a labyrinth of dead references, all the other threads depending on it are patiently waiting dumb. Erlang with its small pieces has a similar trouble - I've faced it myself many times. Smart pointers also have problems of their own - for example memory fragmentation and leaks. Just leave a weak pointer in a loop structure - the whole thing is screwed up. And all that in a language pretending to be safe... If you want a fixed GC time, study your program's behavior under load and take precautions (for example, provide for object pools) if you are not satisfied with the figures, or manage memory manually.
智能指针，让你知道，远不会没有代价，也并不会确保一个固定时间的垃圾收集。假如一些线程荣幸的释放一个非常深的数据结构会发生什么？当死引用在一个迷宫里流浪时，所有依赖它的其他线程都安静的耐心的等待着。Erlang以及它的一小片有同样的困难 - 我曾经自己面对过它许多次。智能指针自己本身也有一些问题 - 例如内存碎片化和泄漏。 就像让一个弱指针在一个循环结构里 - 整件事情搞砸了。所有这些都是一个语言试图假装变得安全点...如果你需要一个固定的GC时间，学习你程序的行为，减轻负载并且采取预防性（举例，提供对象池）如果你不满意这些数字，或者可以手工管理内存。
Has anyone seen a strict description of Rust's semantics? Does it have a memory model at least? And you call it a "safe" language "ensuring correctness" of programs, especially considering that it can interpret the source code in ten different ways?
有人看到Rust里面严格的语义描述吗？它至少有一个内存模型吗？当你考虑到它可以用10种方法翻译源代码，你还会叫它为一个“安全”的语言可以写出“确保正确”的程序？
I can't but remind you for one more time that the source of troubles is usually in humans, not technology . If your C++ code is not good enough or Java code is painfully slow, it's not because the technology is bad - it's because you haven't learned how to use it right. That way, you won't be satisfied with Rust either, but just for some other reasons. Isn't it easier to learn how to use more popular tools and start liking them?
我不能，但再一次提醒你麻烦的根源通常是人，而不是技术。如果你的C++代码没有足够好，或者Java代码很痛苦的运行缓慢，这不是由于这个技术不好 - 这是因为你还没有学会如何正确的使用它。 因此，你也不会因为其他一些理由对Rust满意。学习那些更流行的工具并且喜欢上它不是更容易吗？
So, to sum it up, personally I will be investing my time into studying C/C++ rather than Rust in the next 5 or so years. C++ is an industrial standard. Programmers have been using it to solve a huge variety of tasks for over 30 years now. As for Rust and stuff like that - they are just odd toys with vague future. People have been predicting C++'s soon death since the 2000-s, but C/C++ hasn't become less used and demanded for since then. Quite on the contrary, in fact. It is evolving (C ++11, C++14), new tools are released (take CLion and Clang, for example), and the number of vacancies is just huge.
所以，总结一下，个人来说，在下一个五年左右，我会投资我的时间去学习C/C++而不是Rust。C++是一个工业标准。程序员们已经习惯用它去解决巨量的差异化的任务超过30年了。至于Rust和其他类似的 - 他们仅仅是奇怪的玩具带有模糊的优点。从2000年开始人们已经假设C++很快就会死掉，但自从那时开始起，C/C++并没有变得少用。相反的，事实上，它演进了（C++11, C++14)，新的工具发布了（举例说Clion和Clang)，并且空间巨大。

A C++ programmer will hardly ever have any difficulties finding a job with a more than worthy salary and, if necessary, can quickly learn Rust. But the opposite scenario is very, very unlikely. By the way, the language choice is far not the only and most important factor when picking a new job. Besides, a skilled C/C++ programmer can easily find their way in PostgreSQL's or Linux kernel's source code, has access to modern powerful development tools, and has a pile of books and articles at hand (for example on OpenGL).
一个C++程序员从来不会很难找到一个工资不错的工作，必要的话，可以很快的学会Rust。但相反的情况非常非常不会发生。顺便说一下，找工作时，语言的选择从来都不是唯一和最重要事。另外，一个熟练的C/C++程序员可以容易的学习PostgreSQL's或者Linux核心代码，接触现代的强大的开发工具，并且有一大堆的书和文章在手（比如说OpenGL)

So, take care of your health and don't waste your time - you have less of those than you think!
所以，关心一下你的健康吧，不要浪费你的时间 - 你只有比你想象的更少的时间！